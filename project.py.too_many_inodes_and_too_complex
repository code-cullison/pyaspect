import os
import sys
import copy

import numpy as np

from functools import wraps
from time import time
from tqdm import tqdm

# these are the same symbols at https://realpython.com/directory-tree-generator-python/
PIPE = "│"
ELBOW = "└──"
TEE = "├──"
PIPE_PREFIX = "│   "
SPACE_PREFIX = "    "


def timer(func):
    @wraps(func)
    def wrap(*args, **kwargs):
        t_start = time()
        result = func(*args, **kwargs)
        t_end = time()
        print(f'Function \'{func.__name__}({args},{kwargs})\' executed in {(t_end-t_start):4.3f}s\n')
        return result
    return wrap


MAX_SPEC_SRC = int(9999) # see SPECFEM3D_Cartesian manual


class Project:

    def __init__(self,_proj_path,_proj_name,_nevents,_spec_fqp,_pyutils_fqp,_script_fqp,_forward_only=False):

        self.proj_path  = _proj_path
        self.proj_name = _proj_name
        self.nevents   = _nevents

        self.spec_fqp       = _spec_fqp
        self.spec_bin_fqp   = _spec_fqp + '/bin'
        self.spec_utils_fqp = _spec_fqp + '/utils'

        self.pyutils_fqp = _pyutils_fqp
        self.script_fqp  = _script_fqp

        self.proj_fqdn = _proj_path + '/' + _proj_name + '/'

        self.forward_only = _forward_only

        self.access_rights = 0o755

        self.dir_struct = {}


    def _make_proj_dirs(self,fqdn):
        if os.path.isdir(fqdn):
            print ("The directory %s has already been created" % fqdn)
            return 1
        try:
            os.makedirs(fqdn, self.access_rights)
        except OSError:
            print ("Creation of the directory %s failed" % fqdn)
            print()
            return -1
        else:
            return 0


    def _recursive_mkdir(self,dl,ds,pdir,prefix):

        if len(dl.keys()) == 0:
            return 
        else:
            #print('dl.keys()',dl.keys())
            for dl_key in dl.keys():
                new_dir = pdir + dl_key
                err = self._make_proj_dirs(new_dir)
                if err != 0:
                    print('Oops. Somethig went wrong trying to create %s dir!' %new_dir)
                    assert False
                ds_key = (prefix + ': ',dl_key)
                ds[ds_key] = {}

                self._recursive_mkdir(dl[dl_key],ds[ds_key],new_dir,prefix+prefix)


    def _mk_symlink(self,ds,src,dst,lname,prefix):
        if not os.path.islink(dst):
            os.symlink(src, dst)
        key = (prefix + ': ',lname)
        ds[key] = {}


    def create_project_dirs(self):

        #print(f'in project.create_project_dirs, path:{self.proj_fqdn}')

        # list of directories need for every event
        

        common_dir_struct = {'/DATA': {},
                             '/OUTPUT_FILES' : {'/DATABASES_MPI':{}},
                             '/SEM': {},
                             '/OBS': {},
                             '/SYN': {},
                             '/FILT_OBS': {},
                             '/FILT_SYN': {} }

        # list of directories only needed for the primary run0001 dir
        primary_dir_struct= {'/INPUT_GRADIENT': {},
                            '/INPUT_KERNELS': {},
                            '/INPUT_MODEL': {},
                            '/OUTPUT_MODEL': {},
                            '/OUTPUT_SUM': {},
                            '/SMOOTH': {},
                            '/COMBINE': {},
                            '/topo': {} }



        # create main project dir
        err = self._make_proj_dirs(self.proj_fqdn)
        if err == 0 or err == 1:
            if err == 1:
                return self.dir_struct
        else: 
            print('Oops. Something went wrong trying to creating Project directory!')
            assert False
        key = ('Project Root: ',self.proj_name)
        self.dir_struct[key] = {}
        okey = key

        dir_prefix = '----'
        
        # create project level symlinks 
        lname = 'pyutils'
        src = self.pyutils_fqp
        dst = self.proj_fqdn + '/' + lname
        self._mk_symlink(self.dir_struct[okey],src,dst,lname,dir_prefix)

        lname = 'scriptutils'
        src = self.script_fqp
        dst = self.proj_fqdn + '/' + lname
        self._mk_symlink(self.dir_struct[okey],src,dst,lname,dir_prefix)



        #loop over number of events and create directories
        ookey = okey
        for e in range(self.nevents):

            # calculate meta data
            dir_prefix = '----'
            rdir = '/run' + str(e+1).zfill(4)
            edir = self.proj_fqdn + rdir
            dname = edir
            

            # make event dir
            err = self._make_proj_dirs(edir)
            if err != 0:
                print('Oops. Somethig went wrong trying to create run/event dirs!')
                assert False
            key = (dir_prefix + ': ',rdir)
            self.dir_struct[ookey][key] = {}
            okey = key
            dir_prefix += dir_prefix

                    
            # make sim links for each event dir (related to the computational node(s) filesytem
            lname = 'bin'
            src = self.spec_bin_fqp
            dst = edir + '/' + lname
            self._mk_symlink(self.dir_struct[ookey][okey],src,dst,lname,dir_prefix)

            lname = 'utils'
            src = self.spec_utils_fqp
            dst = edir + '/' + lname
            self._mk_symlink(self.dir_struct[ookey][okey],src,dst,lname,dir_prefix)

            
            # make subdirectorieds for each event
            self._recursive_mkdir(common_dir_struct,self.dir_struct[ookey][okey],dname,dir_prefix)
                
            # make sub-dirs needed only in the primary run0001 dir (used for inversion, model-updating, etc.)
            if e == 0 and not self.forward_only:
                self._recursive_mkdir(primary_dir_struct,self.dir_struct[ookey][okey],dname,dir_prefix)


        return self.proj_fqdn


    def dir_info(self,ds=None):

        if ds == None:
            keys = self.dir_struct.keys()
            for key in keys:
                print(key[0] + self.proj_fqdn)
                self.dir_info(self.dir_struct[key])

        elif len(ds.keys()) == 0:
            return

        else:
            for key in ds.keys():
                print(key[0] + key[1])
                self.dir_info(ds[key])


class SpecDecompMTSources(object):
    
    def __init__(self,proj_path=None,proj_bname=None,ndmt=None,ndec=None):

            
        
        if not isinstance(ndmt,int) and not isinstance(ndmt,np.int32):
            raise TypeError('ndmt must be an integer type')
        
        if ndmt <= 0:
            raise TypeError('ndmt must be a positive integer g.t. zero')
            
        if not isinstance(ndec,int) and not isinstance(ndec,np.int32):
            raise TypeError('ndec must be an integer type')
        
        if ndec <= 0:
            raise TypeError('ndec must be a positive integer g.t. zero')
            
        self.proj_path  = proj_path 
        self.proj_bname = proj_bname 
        self.ndmt   = ndmt     #this is the number of muili-events (multiple moment-tensors)
        self.ndec   = ndec     #this is the number of sigular-events 
        
        # this is the total number of event directories need accross all projects
        self.total_src = int(self.ndmt*self.ndec)
        
        
        # This one can be tricky to understand ** look at '-1'
        # Here we construct the number of SPECFEM project dirs needed
        max_dmt_per_proj  = MAX_SPEC_SRC//self.ndec
        self.num_proj_dir = ((self.ndmt - 1) + max_dmt_per_proj)//max_dmt_per_proj
        
        # Here find the lower bound of the number of (decomposed events) per project.
        # We want to keep each project as balanced as possible regarding number
        # of muilt-directories -- SPECFEM allows for a total of 9999 events, and each
        # decompsed tensor needs 'N' singular-event directories. 
        max_dir_per_proj = int(self.total_src//self.num_proj_dir)
        
        self.min_dmt_per_proj = int(max_dir_per_proj//self.ndec) 
        
        self.list_ndmt_per_proj = np.array([int(self.min_dmt_per_proj)]*self.num_proj_dir)
        
        
        # Now, we need to account for the remaining "extra" dmt's.
        # Again, we want to distribute as evently as possible.
        ndmt_remain = ndmt - sum(self.list_ndmt_per_proj)
        
        for i in range(ndmt_remain):
            self.list_ndmt_per_proj[i] += int(1)
        
        # catch something that might have gone wrong above
        if self.ndmt != sum(self.list_ndmt_per_proj):
            raise Exception('the calculated number of multi events does not match user parameters')
            
            
        # Create the list for the number of event directories (singular events)
        self.list_num_dirs_per_proj = self.ndec * self.list_ndmt_per_proj.copy()
        
        # catch something that might have gone wrong above
        if self.ndmt*self.ndec != sum(self.list_num_dirs_per_proj):
            raise Exception('the calculated number of singular event directories does' +
                            ' not match user parameters')


        #############################################################
        #                                                           # 
        # Now we make 'mapping's of projects to dmt's and dmt's to  #
        # singular-events                                           #
        #                                                           # 
        #############################################################

        self.proj_ids = [pid for pid in range(self.num_proj_dir)]

        self.proj_dict = {}
        for ipid in self.proj_ids:
            dmt_dict = {}
            ie = 0
            esum = 0
            for idmt_id in range(self.list_ndmt_per_proj[ipid]):
                dmt_key = ('Moment-Tensor ID:',idmt_id)
                dmt_val = ('Singular-Event ID\'s:',list(range(ie,ie+self.ndec)))
                dmt_dict[dmt_key] = dmt_val
                ie += self.ndec
                esum += len(dmt_val[1])
            assert esum == self.list_num_dirs_per_proj[ipid]
            self.proj_dict[('Project ID:',ipid)] = dmt_dict

        

    def create_sub_projects(self,spec_fqp=None,pyutils_fqp=None,script_fqp=None):

        sub_proj_dict = {}
        for pkey in self.proj_dict.keys():
            sub_proj_name = f'{self.proj_bname}_{pkey[1]}'
            sub_nevents   = self.list_num_dirs_per_proj[pkey[1]]
            sub_proj = Project(self.proj_path,
                               sub_proj_name,
                               sub_nevents,
                               spec_fqp, 
                               pyutils_fqp,
                               script_fqp,
                               _forward_only=True)
            sub_proj_dict[sub_proj_name] = sub_proj

        return sub_proj_dict



    def create_all_sub_project_dirs(self,sub_proj_dict,show_info=False):
        
        for k,v in sub_proj_dict.items():
            v.create_project_dirs()
            if show_info:
                v.dir_info()




    # end class
            

@timer
def combo_test(scale=20): 

    print('Testing many combinations of ndmt and ndec. Should raise' \
           + ' an \'Exception\' if there is an error.\n')

    min_dmt = 1
    max_dmt = scale*9999 + 1
    print(f'Range of DMTs: ({min_dmt}-{max_dmt-1})')
    for ndec in range(1,7):
        #print('ndec:',ndec)
        #for ndmt in range(min_dmt,max_dmt):
        f_desc = f'Testing DMT Range for ndec={ndec}:'
        for ndmt in tqdm(range(min_dmt,max_dmt), desc=f_desc):
            test = SpecDecompMTSources(proj_path='./',proj_bname='TESTING',ndmt=ndmt,ndec=ndec)

    print()
    print('Done testing combinations of ndmt and ndec')


# To be used as a testing driver only.
def main(*args, **kwargs): #just a test driver

    largs = [arg for larg in args for arg in larg]

    # defaults when no args
    ndmt = 9996*10
    ndec = 6

    if 'ndmt' in kwargs.keys():
        ndmt = int(kwargs['ndmt'])

    if 'ndec' in kwargs.keys():
        ndec = int(kwargs['ndec'])


    print()
    print(f'Constructing project: ndmt={ndmt}, ndec={ndec}')
    make_proj_instance = timer((lambda p,dmt,dec: SpecDecompMTSources(p,'TESTING',dmt,dec)))
    test_proj = make_proj_instance('./',ndmt,ndec)

    print('Number of Singular-Events Per Moment-tensor:',test_proj.ndec)
    print('Number of Moment-Tensors:',test_proj.ndmt)
    print('Number of Singular-Events:',test_proj.total_src)
    print('Number of Poject Directories:',test_proj.num_proj_dir)
    print()

    if '--show_dict' in largs:
        print('Poject ID Dictionary:\n',list(test_proj.proj_dict))
        print()

    if '--show_dirs' in largs:
        print('Number of Momment_Tensors Per Project:',test_proj.list_ndmt_per_proj)
        print()
        print('Number of Singular-Events Per Project:',test_proj.list_num_dirs_per_proj)
        print()


    #show the project dictionary (mapping)
    if '--show_dict' in largs:
        print('Poject ID Dictionary:')
        for pkey in test_proj.proj_dict.keys():
            print(f'{pkey[0]} {pkey[1]}')
            for mkey in test_proj.proj_dict[pkey].keys():
                print(f'pid: {pkey[1]}, mid: {mkey[1]}')
                print(test_proj.proj_dict[pkey][mkey])
        print()
    elif '--show_dict' in kwargs.keys():
        dslices = kwargs['--show_dict'].split(',')
        sp,ep = dslices[0].split(':')
        sp = int(sp)
        ep = int(ep)
        print('Poject ID Dictionary:')
        pid_keys = list(test_proj.proj_dict.keys())[sp:ep]
        for pkey in pid_keys:
            print(f'{pkey[0]} {pkey[1]}')
            if len(dslices) == 1:
                print(test_proj.proj_dict[pkey])
            elif len(dslices) == 2:
                sm,em = dslices[1].split(':')
                sm = int(sm)
                em = int(em)
                mid_keys = list(test_proj.proj_dict[pkey].keys())[sm:em]
                for mkey in mid_keys:
                    print(f'pid: {pkey[1]}, mid: {mkey[1]}')
                    print(test_proj.proj_dict[pkey][mkey])
            else:
                assert False
        print()

    # Check is large combo test shoudl be ran
    if '--test' in largs:
        combo_test() 
    elif '--test' in kwargs.keys():
        combo_test(int(kwargs['--test']))

    if '--create_proj_dirs' in kwargs.keys():
        prt = kwargs['--create_proj_dirs']
        tpj = SpecDecompMTSources(prt,'TESTING',ndmt,ndec)
        print('path:',tpj.proj_path)
        spp='/specfem/bin/path'
        pyp='/pyaspect/pyutils/path'
        bup='/bash_script/utils/path'
        sjd = tpj.create_sub_projects(spp,pyp,bup)

        @timer
        def make_all_dirs(tpj,sjd,show_info=False):
            tpj.create_all_sub_project_dirs(sjd,show_info)

        print('Creating All Dirs (this may take a lot of time')
        make_all_dirs(tpj,sjd,show_info=False)

        #test_proj.create_sub_projects(spp,pyp,bup)
        #test_create_dirs = timer((lambda tpj,spp,pyp,bup: tpj.create_sub_projects(spp,pyp,bup)))
        #test_create_dirs(tpj,spp,pyp,bup)


# To be used as a testing driver only.
if __name__=='__main__':
    m_args = []
    m_kwargs = {}
    for arg in sys.argv[1:]: # kwargs
        up_arg = arg.split('=')
        if len(up_arg) == 2:
            m_kwargs[up_arg[0]] = up_arg[1]
        else:
            m_args.append(up_arg)

    main(*m_args, **m_kwargs) # kwargs


